// webserver.js
// Express server with HTTPS, Basic-auth, separate HTML pages, JSON endpoints,
// and reverse-proxies to the local ONNX/LightGBM predictor and STA service.
// Pages: / (index), /readings, /timeseries, /frostpred, /sta
// JSON:  /data (latest-all), /series (time-series)
// Proxy: /predict → http://127.0.0.1:8060/predict
//        /sta     → http://127.0.0.1:3010 (status/events/etc.)
//
// NOTE: Inline secrets are for dev only. Prefer env vars in production.
// NOTE: For the purposes of expedience t:he sections on Basic-auth, SSL/HTTPS and reverse proxy were generated by Generative AI (GSS-OSS-120B)
const express = require("express");
const crypto  = require("crypto");
const fs      = require("fs");
const path    = require("path");
const http    = require("http");
const https   = require("https");
const { createProxyMiddleware } = require("http-proxy-middleware");

/* ---------- Built-in config (overridable via env) ---------- */
const DEFAULTS = {
  // Basic Auth (password hash/salt from your values)
  BASIC_USER:   "admin",
  BASIC_SALT_B64: "t6OaRMUnL0f9eBrc8Q77rQ==",
  BASIC_HASH_B64: "rjJgngaKpRuSe/6+PjSZNCfqbH4h9H3de3DogDZpCi0=",

  // Upstream API (include stage if needed; trailing slash ok)
  SENSORS_API_BASE: "http://ec2-13-211-237-240.ap-southeast-2.compute.amazonaws.com:3000/",
  SENSORS_API_KEY:  "k8RLAKr6pMY9xSrmJZ74G0asA9N1WYKvi6udhvFDdt0",

  // Field hints passed through to API / used as fallbacks
  SENSOR_FIELD: "sensorId",
  TIME_FIELD:   "time",

  // Time-series path on your API server
  SERIES_PATH: "/sensors/timeseries",

  // Predictor reverse-proxy
  PREDICT_ROUTE:    "/predict",
  // PREDICTOR_TARGET: "http://ec2-13-211-237-240.ap-southeast-2.compute.amazonaws.com:8060",
  PREDICTOR_TARGET: "http://127.0.0.1:8060",

  // STA (Sense-Think-Act) reverse-proxy
  STA_ROUTE:  "/sta",
  // If your STA server is on another host/port, change this:
  STA_TARGET: "http://127.0.0.1:3010",
  // If your STA server serves at root (/status, /events), leave rewrite off.
  // If it expects the /sta prefix on target, set STA_APPEND_PREFIX=true in env.
  STA_APPEND_PREFIX: false,

  // Ports
  PORT:       8080,   // HTTP listener (redirects to HTTPS if TLS present)
  HTTPS_PORT: 8443,   // HTTPS listener

  // TLS files (override via env if desired)
  SSL_KEY_PATH:  "./certs/server.key",
  SSL_CERT_PATH: "./certs/server.crt",
  SSL_CA_PATH:   "",

  ENABLE_HTTP_REDIRECT: false // 301 redirect HTTP→HTTPS when TLS is enabled
};

function getCfg() {
  const cfg = {
    BASIC_USER: process.env.BASIC_USER || DEFAULTS.BASIC_USER,
    BASIC_SALT_B64: process.env.BASIC_SALT_B64 || DEFAULTS.BASIC_SALT_B64,
    BASIC_HASH_B64: process.env.BASIC_HASH_B64 || DEFAULTS.BASIC_HASH_B64,

    SENSORS_API_BASE: process.env.SENSORS_API_BASE || DEFAULTS.SENSORS_API_BASE,
    SENSORS_API_KEY:  process.env.SENSORS_API_KEY  || DEFAULTS.SENSORS_API_KEY,
    SENSOR_FIELD: process.env.SENSOR_FIELD || DEFAULTS.SENSOR_FIELD,
    TIME_FIELD:   process.env.TIME_FIELD   || DEFAULTS.TIME_FIELD,
    SERIES_PATH:  process.env.SERIES_PATH  || DEFAULTS.SERIES_PATH,

    PREDICT_ROUTE:    process.env.PREDICT_ROUTE    || DEFAULTS.PREDICT_ROUTE,
    PREDICTOR_TARGET: process.env.PREDICTOR_TARGET || DEFAULTS.PREDICTOR_TARGET,

    STA_ROUTE:        process.env.STA_ROUTE        || DEFAULTS.STA_ROUTE,
    STA_TARGET:       process.env.STA_TARGET       || DEFAULTS.STA_TARGET,
    STA_APPEND_PREFIX: /^true$/i.test(process.env.STA_APPEND_PREFIX || (DEFAULTS.STA_APPEND_PREFIX ? "true" : "false")),

    PORT:       parseInt(process.env.PORT       || String(DEFAULTS.PORT), 10),
    HTTPS_PORT: parseInt(process.env.HTTPS_PORT || String(DEFAULTS.HTTPS_PORT), 10),

    SSL_KEY_PATH:  process.env.SSL_KEY_PATH  || DEFAULTS.SSL_KEY_PATH,
    SSL_CERT_PATH: process.env.SSL_CERT_PATH || DEFAULTS.SSL_CERT_PATH,
    SSL_CA_PATH:   process.env.SSL_CA_PATH   || DEFAULTS.SSL_CA_PATH,
    SSL_PASSPHRASE: process.env.SSL_PASSPHRASE || "",

    ENABLE_HTTP_REDIRECT:
      (process.env.ENABLE_HTTP_REDIRECT ?? (DEFAULTS.ENABLE_HTTP_REDIRECT ? "1" : "0")) !== "0",
  };

  if (!cfg.BASIC_USER || !cfg.BASIC_SALT_B64 || !cfg.BASIC_HASH_B64) {
    throw new Error("Missing BASIC_* (BASIC_USER, BASIC_SALT_B64, BASIC_HASH_B64)");
  }
  if (!cfg.SENSORS_API_BASE || !cfg.SENSORS_API_KEY) {
    throw new Error("Missing SENSORS_API_* (SENSORS_API_BASE, SENSORS_API_KEY)");
  }
  cfg._salt = Buffer.from(cfg.BASIC_SALT_B64, "base64");
  cfg._hash = Buffer.from(cfg.BASIC_HASH_B64, "base64");
  return cfg;
}

/* ---------- TLS options ---------- */
function getTlsOptions(cfg) {
  try {
    const opts = {
      key:  fs.readFileSync(cfg.SSL_KEY_PATH),
      cert: fs.readFileSync(cfg.SSL_CERT_PATH),
    };
    if (cfg.SSL_CA_PATH) opts.ca = fs.readFileSync(cfg.SSL_CA_PATH);
    if (cfg.SSL_PASSPHRASE) opts.passphrase = cfg.SSL_PASSPHRASE;
    return opts;
  } catch (e) {
    console.warn("[TLS] Could not load certs:", e.message);
    return null; // HTTP-only fallback
  }
}

/* ---------- CORS ---------- */
function corsHeaders(res) {
  res.set({
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "Authorization, Content-Type",
    "Access-Control-Allow-Methods": "GET,OPTIONS",
    "Access-Control-Expose-Headers": "WWW-Authenticate",
    "Vary": "Origin",
  });
}

/* ---------- Helpers ---------- */
function norm(s){ return String(s).toLowerCase().replace(/[^a-z0-9]/g, ""); }
function mapLower(obj){ const m=new Map(); if(!obj||typeof obj!=="object") return m; for(const [k,v] of Object.entries(obj)) m.set(norm(k), v); return m; }
function getCaseInsensitive(obj, keyName){ const m=mapLower(obj); return m.get(norm(keyName)); }
function fromTopOrObject(doc, name){ const vObj=getCaseInsensitive(doc?.object, name); return vObj!==undefined?vObj:getCaseInsensitive(doc, name); }
function pickDeviceName(doc, sensorFieldFromApi){
  return doc?.deviceInfo?.deviceName || doc?.[sensorFieldFromApi] || doc?.sensorId ||
         doc?.deviceInfo?.devEui || doc?.deviceName || doc?._id || "unknown";
}
function pickTime(doc, timeFieldFromApi){
  return doc?.[timeFieldFromApi] || doc?.time || doc?.iso ||
         (doc?.ts ? new Date(doc.ts).toISOString() : undefined) || "";
}

// Permissive extractors for temp/humidity
function getTempCandidate(doc){
  const names = [
    "TempC_SHT","TempC1","temperature_c","temperatureC","temperature",
    "temp_c","tempC","temp","tC","temp_sht","temp1"
  ];
  for (const n of names){
    const v = fromTopOrObject(doc, n);
    if (v !== undefined && v !== null && v !== "" && isFinite(Number(v))) return Number(v);
  }
  return undefined;
}
function getHumidityCandidate(doc){
  const names = ["Hum_SHT","hum","humidity","hum_SHT","hum_SMT","relative_humidity","rh"];
  for (const n of names){
    const v = fromTopOrObject(doc, n);
    if (v !== undefined && v !== null && v !== ""){
      if (typeof v === "number" && Math.abs(v - 6553.5) < 1e-6) return "NA"; // special NA
      if (isFinite(Number(v))) return Number(v);
      return v; // e.g. "NA"
    }
  }
  return undefined;
}

/* ---------- Basic Auth middleware ---------- */
async function checkBasicAuth(req, res, next) {
  const cfg = getCfg();
  const auth = req.get("authorization");
  if (!auth || !auth.startsWith("Basic ")) {
    corsHeaders(res);
    res.set("WWW-Authenticate", 'Basic realm="Sensors Web"');
    return res.status(401).type("text").send("Authentication required");
  }
  try {
    const decoded = Buffer.from(auth.slice(6), "base64").toString("utf8");
    const i = decoded.indexOf(":"); if (i < 0) throw new Error("invalid basic format");
    const user = decoded.slice(0, i);
    const pass = decoded.slice(i + 1);
    if (user !== cfg.BASIC_USER) throw new Error("user mismatch");
    const derived = crypto.scryptSync(pass, cfg._salt, cfg._hash.length);
    if (!crypto.timingSafeEqual(derived, cfg._hash)) throw new Error("bad password");
    return next();
  } catch {
    corsHeaders(res);
    res.set("WWW-Authenticate", 'Basic realm="Sensors Web"');
    return res.status(401).type("text").send("Authentication failed");
  }
}

/* ---------- HTTP/HTTPS client wrapper ---------- */
async function callApi(url, headers) {
  if (typeof fetch === "function") {
    const r = await fetch(url, { headers, cache: "no-store", method: "GET" });
    const text = await r.text();
    return { status: r.status, data: text };
  }
  const u = new URL(url);
  const client = u.protocol === "http:" ? http : https;
  return await new Promise((resolve, reject) => {
    const req = client.request(u, { method: "GET", headers }, (res) => {
      let data = ""; res.on("data", c => data += c);
      res.on("end", () => resolve({ status: res.statusCode, data }));
    });
    req.on("error", reject);
    req.end();
  });
}

/* ---------- Sensors API: Latest ---------- */
async function fetchLatestAllFromApi(cfg) {
  const base = cfg.SENSORS_API_BASE.replace(/\/$/, "");
  const url = new URL(`${base}/sensors/latest-all`);
  url.searchParams.set("sensorField", cfg.SENSOR_FIELD);
  url.searchParams.set("timeField",  cfg.TIME_FIELD);

  const payload = await callApi(url.toString(), { "x-api-key": cfg.SENSORS_API_KEY });
  if (payload.status !== 200) throw new Error(`sensors-api ${payload.status}: ${payload.data}`);
  const json = JSON.parse(payload.data);

  const items = (json.items || []).flatMap((doc) => {
    const deviceName        = pickDeviceName(doc, json.sensorField || "sensorId");
    const deviceProfileName = (doc?.deviceInfo?.deviceProfileName || "").trim();
    const time              = pickTime(doc, json.timeField || "time");

    let temperature;
    if (deviceProfileName === "LSN50v2-S31") temperature = fromTopOrObject(doc, "TempC_SHT");
    else if (deviceProfileName === "LSN50-V2") temperature = fromTopOrObject(doc, "TempC1");
    if (temperature == null) temperature = getTempCandidate(doc);

    const humidity = getHumidityCandidate(doc);
    if (temperature == null && humidity == null) return [];
    return [{ deviceName, deviceProfileName, time, temperature, humidity }];
  });

  return { sensorField: "deviceName", timeField: "time", items };
}

/* ---------- Sensors API: Time Series ---------- */
async function fetchSeriesFromApi(cfg, fromIso, toIso) {
  const base = cfg.SENSORS_API_BASE.replace(/\/$/, "");
  const url = new URL(`${base}${cfg.SERIES_PATH || "/sensors/timeseries"}`);
  if (fromIso) url.searchParams.set("from", fromIso);
  if (toIso)   url.searchParams.set("to",   toIso);
  url.searchParams.set("sensorField", cfg.SENSOR_FIELD);
  url.searchParams.set("timeField",   cfg.TIME_FIELD);

  console.log("[series] GET", url.toString());
  const payload = await callApi(url.toString(), { "x-api-key": cfg.SENSORS_API_KEY });
  if (payload.status !== 200) throw new Error(`sensors-api ${payload.status}: ${payload.data}`);

  const json = JSON.parse(payload.data);
  const sensorFieldFromApi = json.sensorField || cfg.SENSOR_FIELD;
  const timeFieldFromApi   = json.timeField   || cfg.TIME_FIELD;
  const raw = Array.isArray(json) ? json : (json.items || []);

  const points = raw.map((doc) => {
    const sensorName = pickDeviceName(doc, sensorFieldFromApi);
    const time       = pickTime(doc, timeFieldFromApi);
    const temperature = getTempCandidate(doc);
    const humidity    = getHumidityCandidate(doc);
    return { sensorName, time, temperature, humidity };
  }).filter(p => p.time);

  console.log(`[series] normalized points=${points.length} (from=${fromIso || "-"} to=${toIso || "-"})`);
  return points;
}

/* ---------- HTML file helpers ---------- */
const PUBLIC_DIR = path.join(__dirname, "public");
const sendHtml = (res, filename) =>
  res.status(200).type("html").set("Cache-Control","no-store")
     .send(fs.readFileSync(path.join(PUBLIC_DIR, filename), "utf8"));

/* ---------- Express app ---------- */
const app = express();
const cfg = getCfg();

app.set("trust proxy", true);
app.use((req, res, next) => {
  corsHeaders(res);
  const isHttps = req.secure || req.headers["x-forwarded-proto"] === "https";
  if (isHttps) res.set("Strict-Transport-Security", "max-age=31536000; includeSubDomains");
  if (req.method === "OPTIONS") return res.status(204).send("");
  next();
});

/* ---- Protected pages ---- */
app.get("/",            checkBasicAuth, (_req, res) => sendHtml(res, "index.html"));
app.get("/readings",    checkBasicAuth, (_req, res) => sendHtml(res, "readings.html"));
app.get("/timeseries",  checkBasicAuth, (_req, res) => sendHtml(res, "timeseries.html"));
app.get("/frostpred",   checkBasicAuth, (_req, res) => sendHtml(res, "frostpred.html"));
app.get("/sta",         checkBasicAuth, (_req, res) => sendHtml(res, "sta.html")); // optional page for STA UI

/* ---- Protected static assets ---- */
app.use("/lib", checkBasicAuth, express.static(path.join(PUBLIC_DIR, "lib"), {
  etag: false, lastModified: false, cacheControl: false,
  setHeaders(res) { res.set("Cache-Control","no-store"); }
}));

/* ---- Protected JSON endpoints ---- */
app.get("/data", checkBasicAuth, async (_req, res) => {
  try {
    const data = await fetchLatestAllFromApi(cfg);
    res.status(200).type("json").set("Cache-Control","no-store").send(JSON.stringify(data));
  } catch (e) {
    console.error(e);
    res.status(500).type("text").send(e?.message || "Server error");
  }
});

app.get("/series", checkBasicAuth, async (req, res) => {
  try {
    const fromIso = req.query.from || "";
    const toIso   = req.query.to   || "";
    const points  = await fetchSeriesFromApi(cfg, fromIso, toIso);
    res.status(200).type("json").set("Cache-Control","no-store").send(JSON.stringify({ points }));
  } catch (e) {
    console.error(e);
    res.status(500).type("text").send(e?.message || "Server error");
  }
});

/* ---- Predictor reverse proxy (/predict) ----
   NOTE: The predictor expects the path to include '/predict' on the target,
   so we re-append it (mount strips it). */
app.use(
  cfg.PREDICT_ROUTE,              // e.g. '/predict'
  checkBasicAuth,
  createProxyMiddleware({
    target: cfg.PREDICTOR_TARGET, // e.g. 'http://127.0.0.1:8060'
    changeOrigin: true,
    secure: false,
    xfwd: true,
    ws: false,
    proxyTimeout: 15000,
    timeout: 20000,
    // Re-add '/predict' because Express mount strips it off
    pathRewrite: (_path, _req) => '/predict' + _path, // '/' -> '/predict/', '/?a=b' -> '/predict/?a=b'
    onError(err, req, res) {
      console.error('[predict-proxy] error:', err?.message || err);
      res.writeHead(504, { 'Content-Type': 'text/plain' });
      res.end('Proxy error (predictor unreachable or timed out).');
    },
    logLevel: 'warn',
  })
);

/* ---- STA reverse proxy (/sta) ----
   Default behavior: STA server serves endpoints at root (/status, /events).
   Since Express mount strips '/sta', we can forward the stripped path as-is.
   If your STA server expects '/sta' prefix on target, set STA_APPEND_PREFIX=true. */
app.use(
  cfg.STA_ROUTE,                 // e.g. '/sta'
  checkBasicAuth,
  createProxyMiddleware({
    target: cfg.STA_TARGET,      // e.g. 'http://127.0.0.1:3010' OR 'http://remote-host:3010'
    changeOrigin: true,
    secure: false,
    xfwd: true,
    ws: true,                    // allow SSE/websocket passthrough
    proxyTimeout: 25000,
    timeout: 30000,
    pathRewrite: cfg.STA_APPEND_PREFIX
      ? (path, _req) => cfg.STA_ROUTE + path // keep /sta prefix on target if needed
      : undefined,                            // otherwise leave as '/status', '/events', etc.
    onError(err, req, res) {
      console.error('[sta-proxy] error:', err?.message || err);
      res.writeHead(504, { 'Content-Type': 'text/plain' });
      res.end('Proxy error (STA unreachable or timed out).');
    },
    logLevel: 'warn',
  })
);

/* ---------- Start servers ---------- */
const tlsOpts = getTlsOptions(cfg);

if (tlsOpts) {
  https.createServer(tlsOpts, app).listen(cfg.HTTPS_PORT, () => {
    console.log(`[sensors-web] HTTPS listening on https://localhost:${cfg.HTTPS_PORT}`);
  });

  if (cfg.ENABLE_HTTP_REDIRECT) {
    http.createServer((req, res) => {
      const hostHeader = req.headers.host || `localhost:${cfg.PORT}`;
      const host = hostHeader.replace(/:.*/, "");
      res.statusCode = 301;
      res.setHeader("Location", `https://${host}:${cfg.HTTPS_PORT}${req.url}`);
      res.end();
    }).listen(cfg.PORT, () => {
      console.log(`[sensors-web] HTTP redirector on http://localhost:${cfg.PORT} -> HTTPS`);
    });
  } else {
    http.createServer(app).listen(cfg.PORT, () => {
      console.log(`[sensors-web] HTTP listening on http://localhost:${cfg.PORT}`);
    });
  }
} else {
  http.createServer(app).listen(cfg.PORT, () => {
    console.log(`[sensors-web] HTTP (no TLS) listening on http://localhost:${cfg.PORT}`);
  });
}

/* ---------- Helper (optional): generate salt/hash for a password ----------
   Usage (temporarily uncomment and run once, then paste into DEFAULTS):
   node -e "const c=require('crypto');const p='your-password';const s=c.randomBytes(16);const h=c.scryptSync(p,s,32);console.log('BASIC_SALT_B64='+s.toString('base64'));console.log('BASIC_HASH_B64='+h.toString('base64'));"
---------------------------------------------------------------------------- */
